;; This creation code implements input addressing. This means: the address of a contract reflects a function (which is another contract) and an input value, and the contract at that address is the output of that function on the given input. Since it is possible to compute the address without knowing the output, this allows looking up an output on-chain that was previously computed.

:start
PUSH20 '00000000 00000000 00000000 00000000 00000004' ; input address, here the identity precompile but to be substituted
DUP1 ; save at the bottom of the stack
EXTCODESIZE
PUSH1 !contract_check_ok>start
JUMPI
; the contract has not been deployed, abort
INVALID

:contract_check_ok
JUMPDEST

PUSH0                   ; STACK STATE
PUSH1 !input_data>start ; data_offset, 0, function_address
DUP1                    ; data_offset, data_offset, ...
CODESIZE                ; codesize, data_offset, data_offset, ...
SUB                     ; codesize - data_offset, data_offset, ...
DUP1                    ; codesize - data_offset, codesize - data_offset, data_offset, ...
SWAP2                   ; data_offset, codesize - data_offset, codesize - data_offset, ...
PUSH0                   ; 0, data_offset, codesize - data_offset, codesize - data_offset, ...
CODECOPY                ; codesize - data_offset, ...
PUSH0                   ; 0, codesize - data_offset, ...
PUSH0                   ; 0, 0, codesize - data_offset, ...
PUSH0                   ; 0, 0, 0, codesize - data_offset, ...
SWAP5                   ; function_address, 0, 0, 0, codesize - data_offset, 0
GAS                     ; gas, function_address, 0, 0, 0, codesize - data_offset, 0
CALL
PUSH1 !call_status_ok>start
JUMPI
; the contract reverted: abort
INVALID

:call_status_ok
JUMPDEST
RETURNDATASIZE
PUSH0
PUSH0
RETURNDATACOPY

RETURNDATASIZE
PUSH0
RETURN

:input_data
;; unreachable by execution, input data goes here
